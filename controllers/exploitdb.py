# -*- coding: utf-8 -*-

##--------------------------------------#
## Kvasir
##
## (c) 2010-2014 Cisco Systems, Inc.
##
## Exploit database controller
##
## Download from https://github.com/offensive-security/exploit-database and place in a directory
## In kvasir.yaml set the directory in exploitdb_path, e.g. exploitdb_path: "/usr/share/exploitdb"
##
## Author: Kurt Grutzmacher <kgrutzma@cisco.com>
##--------------------------------------#

try:
    import git
    if git.__version__ < '0.3.1':
        raise ImportError("Your version of git is %s. Upgrade to 0.3.1 or better." % git.__version__)
    have_git = True
except ImportError, e:
    have_git = False
    GIT_MISSING = 'Requires gitpython module, but not installed or incompatible version: %s' % e

import os
import mimetypes
import logging
logger = logging.getLogger("web2py.app.kvasir")
crud.settings.formstyle = formstyle_bootstrap_kvasir


@auth.requires_login()
def index():
    response.title = "%s :: The Exploit Database" % (settings.title)
    return dict()


@auth.requires_login()
def list():
    """
    #@cache('exploitdb', 3600, cache.ram)
    List exploitdb using server-side json
    """

    if request.vars.has_key('iDisplayStart'):
        start = int(request.vars.iDisplayStart)
    else:
        start = 0
    if request.vars.has_key('iDisplayLength'):
        if request.vars.iDisplayLength == '-1':
            limit = db(db.t_vulndata).count()
        else:
            limit = start + int(request.vars.iDisplayLength)
    else:
        limit = int(auth.user.f_show_size)

    if request.vars.has_key('sSearch'):
        # sSearch global search box
        srch = request.vars.sSearch
        query = (
            #(db.t_exploitdb.id == srch) | \
            (db.t_exploitdb.f_description.contains(srch)) | \
            (db.t_exploitdb.f_author.contains(srch)) | \
            (db.t_exploitdb.f_platform.contains(srch)) | \
            (db.t_exploitdb.f_type.contains(srch))
        )
    else:
        query = (db.t_exploitdb.id > 0)

    #orderby = db.t_expoitdb.f_date
    if request.vars.iSortingCols == '1':
        # sorting by a column - this is a little trippy because tuples start at 0
        # and datatables starts at 1 so we have to subtract 1 from iSortCol_0
        cols = (
            db.t_exploitdb.id,
            db.t_exploitdb.f_description,
            db.t_exploitdb.f_date,
            db.t_exploitdb.f_author,
            db.t_exploitdb.f_platform,
            db.t_exploitdb.f_type,
            db.t_exploitdb.f_port,
        )

        orderby = cols[int(request.vars.iSortCol_0)]
        if request.vars.sSortDir_0 == 'asc':
            rows=db(query).select(orderby=orderby, limitby=(start, limit), cacheable=True)
        else:
            rows=db(query).select(orderby=~orderby, limitby=(start, limit), cacheable=True)
    else:
        rows=db(query).select(orderby=~orderby, limitby=(start,limit), cacheable=True)

    aaData = []
    for r in rows:
        aaData.append( {
            '0': A(r.id, _id='id', _href=URL('detail', extension='html', args=[r.id]), _target="_blank").xml(),
            '1': A(r.f_description, _id='description', _href=URL('detail', extension='html', args=[r.id]), _target="_blank").xml(),
            '2': r.f_date,
            '3': r.f_author,
            '4': r.f_platform,
            '5': r.f_type,
            '6': r.f_port,
        } )

    total = db(db.t_exploitdb).count()
    result = {
        'sEcho': request.vars.sEcho,
        'iTotalRecords': total,
        'iTotalDisplayRecords': total,
        'aaData': aaData,
    }

    response.title = "%s :: The Exploit Database" % (settings.title)
    return result


@auth.requires_login()
def detail():
    """
    Serve up details of a specific exploitdb item
    """
    if request.args(0) is None:
        redirect(URL('index'))

    record = db(db.t_exploitdb.id == request.args(0)).select(cacheable=True).first()
    if not record:
        redirect(URL('default', 'error', vars={'msg': T('Exploit DB record not found')}))

    contents = None
    extension = None
    if record.f_file:
        mtype = mimetypes.guess_type(record.f_file)
        if mtype[0].startswith("text"):
            filename = os.path.join(settings.exploitdb_path, record.f_file)
            try:
                contents = "".join(open(filename, "r").readlines())
            except IOError, e:
                contents = None
            extension = record.f_file[record.f_file.rfind('.')+1:]
            shBrushes = {
              'sh':   ['shBrushBash.js', 'bash'],
              'c':    ['shBrushCpp.js', 'c'],
              'cs':   ['shBrushCSharp.js', 'csharp'],
              'css':  ['shBrushCss.js', 'css'],
              'java': ['shBrushJava.js', 'java'],
              'js':   ['shBrushJScript.js', 'javascript'],
              'pl':   ['shBrushPerl.js', 'perl'],
              'php':  ['shBrushPhp.js', 'php'],
              'py':   ['shBrushPython.js', 'python'],
              'rb':   ['shBrushRuby.js', 'ruby'],
              'sql':  ['shBrushSql.js', 'sql'],
              'vb':   ['shBrushVb.js', 'vb'],
              'xml':  ['shBrushXml.js', 'xml'],
              'html': ['shBrushXml.js', 'html'],
              'htm':  ['shBrushXml.js', 'html'],
            }
            shJsFile = shBrushes.get(extension, ['shBrushPlain.js', 'plain'])

    response.title = "%s :: ExploitDB %s :: %s" % (settings.title, str(record.id), record.f_description)
    return dict(record=record, contents=contents, shJsFile=shJsFile)


@auth.requires_login()
def download():
    """
    Dowload exploitdb file
    """
    if request.args(0) is None:
        redirect(URL('index'))

    record = db(db.t_exploitdb.id == request.args(0)).select(cacheable=True).first()
    if not record:
        redirect(URL('default', 'error', vars={'msg': T('Exploit DB record not found')}))

    filename = os.path.basename(record.f_file)
    fullfilename = os.path.join(settings.exploitdb_path, record.f_file)
    try:
        contents = open(fullfilename, "r").readlines()
    except IOError, e:
        contents = None

    mtype = mimetypes.guess_type(fullfilename)[0]
    if not mtype:
        mtype = 'text/txt'

    response.headers['Content-Type'] = mtype
    response.headers['Content-Disposition'] = 'attachment; filename="%s"' % filename
    return contents


@auth.requires_login()
def db_update():
    """
    Update the database with latest files.csv
    """
    if settings.exploitdb_path:
        if not os.path.exists(settings.exploitdb_path):
            redirect(URL('default', 'error', vars={'msg': T('Exploit DB directory in kvasir.yaml not valid')}))

    import csv
    import os
    indexfile = os.path.join(settings.exploitdb_path, 'files.csv')

    if not os.path.exists(indexfile):
        redirect(URL('default', 'error', vars={'msg': T('Exploit DB files.csv not found')}))

    db.t_exploitdb.truncate()
    db.commit()

    reader = csv.DictReader(open(indexfile, 'rb'), delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    for line in reader:
        db.t_exploitdb.insert(
            id=line['id'],
            f_file=line['file'],
            f_description=line['description'],
            f_date=line['date'],
            f_author=line['author'],
            f_platform=line['platform'],
            f_type=line['type'],
            f_port=line['port'],
        )

    db.commit()
    if db(db.t_exploitdb).count() == 0:
        redirect(URL('invalid'))
    else:
        redirect(URL('index'))


@auth.requires_login()
def git_pull():
    """
    Git Pull handler
    """
    if not have_git:
        session.flash = GIT_MISSING
        redirect(URL('invalid'))

    if settings.exploitdb_path:
        if not os.path.exists(settings.exploitdb_path):
            redirect(URL('invalid'))

    dialog = FORM.confirm(T('Pull'),
                          {T('Cancel'): URL('index')})
    if dialog.accepted:
        try:
            repo = git.Repo(settings.exploitdb_path)
            origin = repo.remotes.origin
            origin.fetch()
            origin.pull()
            session.flash = T("Exploit-database updated")
            redirect(URL('db_update'))

        except git.CheckoutError:
            session.flash = T("Pull failed, certain files could not be checked out. Check logs for details.")
            redirect(URL('index'))
        except git.UnmergedEntriesError:
            session.flash = T("Pull is not possible because you have unmerged files. Fix them up in the work tree, and then try again.")
            redirect(URL('index'))
        except git.GitCommandError:
            session.flash = T(
                "Pull failed, git exited abnormally. See logs for details.")
            redirect(URL('index'))
        except AssertionError:
            session.flash = T("Pull is not possible because you have unmerged files. Fix them up in the work tree, and then try again.")
            redirect(URL('index'))
    elif 'cancel' in request.vars:
        redirect(URL('index'))
    return dict(dialog=dialog)


