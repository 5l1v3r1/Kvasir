# -*- coding: utf-8 -*-

##--------------------------------------#
## Kvasir
##
## (c) 2010-2014 Cisco Systems, Inc.
##
## Exploit database controller
##
## Download from https://github.com/offensive-security/exploit-database and place in a directory
## In kvasir.yaml set the directory in exploitdb_path, e.g. exploitdb_path: "/usr/share/exploitdb"
##
## Author: Kurt Grutzmacher <kgrutzma@cisco.com>
##--------------------------------------#

try:
    import git
    if git.__version__ < '0.3.1':
        raise ImportError("Your version of git is %s. Upgrade to 0.3.1 or better." % git.__version__)
    have_git = True
except ImportError, e:
    have_git = False
    GIT_MISSING = 'Requires gitpython module, but not installed or incompatible version: %s' % e

import os
import logging
logger = logging.getLogger("web2py.app.kvasir")
crud.settings.formstyle = formstyle_bootstrap_kvasir


@auth.requires_login()
def index():
    response.title = "%s :: The Exploit Database" % (settings.title)
    return dict()


@auth.requires_login()
@cache('exploitdb', 3600, cache.ram)
def list():
    rows = db(db.t_exploitdb).select(
        db.t_exploitdb.id,
        db.t_exploitdb.f_description,
        db.t_exploitdb.f_date,
        db.t_exploitdb.f_author,
        db.t_exploitdb.f_platform,
        db.t_exploitdb.f_type,
        db.t_exploitdb.f_port,
        cacheable=True
    )

    aaData = []
    for r in rows:
        aaData.append( {
            '0': A(r.f_id, _id='id', _href=URL('detail', extension='html', args=[r.id]), _target="_blank" % (r.id)).xml(),
            '1': r.f_description,
            '2': r.f_date,
            '3': r.f_author,
            '4': r.f_platform,
            '5': r.f_type,
            '6': r.f_port,
        } )

    result = {
        'sEcho': request.vars.sEcho,
        'iTotalRecords': len(aaData),
        'iTotalDisplayRecords': len(aaData),
        'aaData': aaData,
    }

    response.title = "%s :: The Exploit Database" % (settings.title)
    return result


@auth.requires_login()
def detail():
    """
    Serve up details of a specific exploitdb item
    """
    if request.args(0) is None:
        redirect(URL('index'))

    record = db(db.t_exploitdb.id == request.args(0)).select(cacheable=True).first()
    if not record:
        redirect(URL('default', 'error', vars={'msg': T('Exploit DB record not found')}))

    response.title = "%s :: ExploitDB %s :: %s" % (settings.title, str(record.id), record.f_description)
    return dict(record=record)


@auth.requires_login()
def fileview():
    """
    Load the file contents if extension matches
    """
    if request.args(0) is None:
        redirect(URL('index'))

    record = db(db.t_exploitdb.id == request.args(0)).select(cacheable=True).first()
    if not record:
        redirect(URL('default', 'error', vars={'msg': T('Exploit DB record not found')}))

    response.title = "%s :: %s" % (settings.title, str(record.id), record.f_description)

    return dict(record=record)



@auth.requires_login()
def db_update():
    """
    Update the database with latest files.csv
    """
    if settings.exploitdb_path:
        if not os.path.exists(settings.exploitdb_path):
            redirect(URL('default', 'error', vars={'msg': T('Exploit DB directory in kvasir.yaml not valid')}))

    import csv
    import os
    indexfile = os.path.join(settings.exploitdb_path, 'files.csv')

    if not os.path.exists(indexfile):
        redirect(URL('default', 'error', vars={'msg': T('Exploit DB files.csv not found')}))

    db.t_exploitdb.truncate()
    db.commit()

    reader = csv.DictReader(open(indexfile, 'rb'), delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    for line in reader:
        db.t_exploitdb.insert(
            id=line['id'],
            f_file=line['file'],
            f_description=line['description'],
            f_date=line['date'],
            f_author=line['author'],
            f_platform=line['platform'],
            f_type=line['type'],
            f_port=line['port'],
        )

    db.commit()
    if db(db.t_exploitdb).count() == 0:
        redirect(URL('invalid'))
    else:
        redirect(URL('index'))


@auth.requires_login()
def git_pull():
    """
    Git Pull handler
    """
    if not have_git:
        session.flash = GIT_MISSING
        redirect(URL('invalid'))

    if settings.exploitdb_path:
        if not os.path.exists(settings.exploitdb_path):
            redirect(URL('invalid'))

    dialog = FORM.confirm(T('Pull'),
                          {T('Cancel'): URL('index')})
    if dialog.accepted:
        try:
            repo = git.Repo(settings.exploitdb_path)
            origin = repo.remotes.origin
            origin.fetch()
            origin.pull()
            session.flash = T("Exploit-database updated")
            redirect(URL('db_update'))

        except git.CheckoutError:
            session.flash = T("Pull failed, certain files could not be checked out. Check logs for details.")
            redirect(URL('index'))
        except git.UnmergedEntriesError:
            session.flash = T("Pull is not possible because you have unmerged files. Fix them up in the work tree, and then try again.")
            redirect(URL('index'))
        except git.GitCommandError:
            session.flash = T(
                "Pull failed, git exited abnormally. See logs for details.")
            redirect(URL('index'))
        except AssertionError:
            session.flash = T("Pull is not possible because you have unmerged files. Fix them up in the work tree, and then try again.")
            redirect(URL('index'))
    elif 'cancel' in request.vars:
        redirect(URL('index'))
    return dict(dialog=dialog)


